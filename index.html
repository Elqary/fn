<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://api.whatsapp.com/send/?phone=%2B201015817243&text=Ù…Ø±Ø­Ø¨Ø§ ðŸ‘‹               Ø§Ø±ÙŠØ¯ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙƒÙˆØ±Ø³Ø§Øª Ù…Ù† ÙØ¶Ù„Ùƒ .&type=phone_number&app_absent=0"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Get Password 
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>This is a courses website.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

 <!--!   <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>!-->

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1de0fa549b4cc52a90dbb1d9c89ca1bbfc1e655339b8a4a5f27eb559437def86e41be7ea7b4e4048a86e9141f8ad721664baef7c9ca35f48efcdbf159c0829341bab7fbfde202dc2a8998414939fe1aa0ea65941d3257628480ffd80d540ab0a5c82972aaf988a16392ed55adc8fcc7588417321e786d519dfe921e00de92af1885436fc320af31a6d87ca7d415305924337813ce2f95ba07b1743e8f7026768fa5f8102daecc2a56b215a9336e0a6503cce7448dab1a0a3e0e19b93113e314acfe332792fe4a0c7ef719e24c2ad25a4ee289670be9882f1c50fc7d7dba19a7ec8387c6ce8623d70dc1bfc20d4fd8a4f1bea1d559e1eafb1f024cf97ef418da15f5137d350813f8b035cf67f61c29a1e90c86de071bc1c29032bc94d8608bd06c4c7cf2b201b379c01a1be9e7ab653fa2ba07947a7757d51c3e621b1f68a6bcf74f9f5a4be27a88a4541914d782c5564c6e392834a0d1f87d3b2b31ba9daa26173e8fa374924c006c8d13366bb54b9f7569dc32b13ba5d75a3d7bf3ae71b445c976798ad737998386cd37b7076a5bb2893c05d788e4ef50c1588b906d3162b7e78a55fe80f07ddfa7efcc16f5bc3d6c39ff5a625bd7e52ef9d65cfa122e686ec42bbe1d34771c0407288f5896d695e57bbe87a7e5826b3376e5dfb8e5042b1685d55fc7adcf78427a0423d0ac4232d3991252a87d74d9a68bb00aa7a603062e43419789be4aba5bb64bd730c46b29490bafeb5e212dd2cbbccd06d44f6529b487d991553637bfc6eb3b42851cb5749c994e87f3c3558105222b85ce8647f16dda3be1cfc145618517163eab68c3630e0fb992ae60dca2f4d0c80a350319fbc418847164387c7d896466bd4f2c84d71c5f39db4be8880b365046bb55b3f1c829d6c00e80d0072d3f652378b59f845ecd0750bde7a21f816a41d91d8943d5d258060d660a858467539a396f9aeb68fba3361cfd6eecf235234452a8f6762e87055003bb9d7b5b652751789f5e31c8e717ddf4e85a7a17e220c3723937cc6e2a42faf2567ec8689acb2b66d94dabb0892cad231d547d42949420137d8adfb02cc1d49f2241cb16ee243b192ecd6123ffe1999938aa8310da698d5520c85248f18dba673664d03204b54571d7b66eff98f5ec15d38402fc34e4922d99ef5e00290c43098e4f2284411633b1b2548b4efc14854371af4b8773a5082ccd5d607e25c33d2633b0fc1510a1155bd5d46d6a81d7ffeb14034a153526a90db29e822543c621ea1bad382060d613e82a5d47427de74b2c660fe28130f6363f3df04ca289513612605e5d2a4fdae46b85b333be4b34b51d99ec80a3de718a8f11e640def13727d3e01bc169c191992fa649170bc3cb53d875a0872dbc82fa90982d6f5702cf378174fb96aac8262268eb14047240e8e1c5dc299d3f6c38003bbc2dd87321a56abd6812b36f14a68c889926dfebcfb9f5480dd1efb9c555a029c06670cd0ce7486d8af2aa9f87eba6d808048d85c59465354acd8cdfa5b78d0f4aa80a150296961fd0c273329a864e6301134b93158f3442d8e89bc04a4787b005cf8b6ec1f53bcb26a49111aec5fe76d26d54ca2122b1eb6a8c6f5c52fd4b3786ae62879e934b626b629ec53b5b916323fd01ab14a0c667c837f09c98c0662f6f9e9e0f3551cb06645f8c14cd6f60e4a3305862bea8c9b3ad384b2893e4f606f195307ca1da5f7663719503b8f0a1033788381a1f6454b276683d44fc91dbc93c966c16e50cfe5b8f5f4e6092977f83c2ac9b6ea8ad04d8d13fc79cd2f2d63c797eef81c4bfb583a1c8310d883eedeaa772576a240688ca57886eba89a77a0d994277ca0bb616b266309d173857392b9ba6f868fc912d12653b932e46c59fec19529f1189e81d41427e4f52d69dd2c920a4ab1d2f9bc78f2e69de2ec9387311c3e5e997135ecbe870fe6d337ba1489de727416d50a37373556dd997e1cf514367253eb1efdedfcba104d441fd418f3a3b80e21c5be14d419f40b23ad05da0e4568a00f4a5e7a29442813c1efe04e565293b0dd9ce89dbb1408157ca164ee58b15618d87f03be938a418cbd0b244f0160f1a17519f0da685cd03a3fd45ce16c9746087358b35a2128107366149404ede12443502740332a4796f866cc3a954282375e1480ba1ae72ffcf9235f063f5a27c0e70955b30c27923f4b6599b9c53d36a04fa04fac9c5beea863213cc4765aaadd009b6bd1e12afc26430f2ab3cd3853bb6527b4ead9867c2dc7ffa9e075931144cd7aa217fb78888c391c0b8c6b9727d996f2c54b3c10b331fbbdb54907c38f2736d63b50c58caecb8053fc02bed7c108994ac137c4df6d24ecdc111af163861472a1c64529a0bdf3eae97afbe5cb744a5d6a71ba69e83c762ab58c02b49c81aae5b379bc3d9e564df92c733692cc55652494b862a6f5a497a323868fa50fa35474b53a4c20afa78817e21d73405788e052b3986194447b146451d2eee5a3e6e35fc21709c0b1177d5c5b39f418cc8403e248503e0919ed14fe23ca9ffedafb32f65a617c964d89b4ff317e990a218af42f755a664bc51bf03a789b239b6fb82a4af2a99e6118ba9f923fc28b273a1cbe1c66d50abb8b1067dda14433c190228cd7e9395501054c0447c6a724eda27abed8eaa9be08c75fc4126b0283fcbf8e80b8277dafb20cb716c36ad7643308050230e6ab19006c8b6ac6522b520b47d97e306cc434f3a1039fe61556643b05f47fce387795a1989b542a86624fcd6a10cc7adabe560153b9ee64a69aa781d608d255dfbea66b2bdeb272b030d6dba6ecf0affc19a46fa10b09e997d03742d67cae31e810337336240da3be5ef87578422f86efcf0be382a09c0dc82a415193c91972616f4e1e8842021821c2f9aca885c2951185f6c490f9dbb8fd939d5274c5e3a977b4c5fe3ad723969c990cb25dd3188f501dd547e388ba5720936b458725a7e87b87a10de14d0fbb5e092782e27267932a708b22c2d80db4ba5ab63fbc96d1afb8cd70023db006c7d914806bdd9712050d7e3492bb2593a05329ff4efa5eada17ee12600fe4c83f62746b97c24d739cebe57e1829d1fb628814b83e8abae15fe3f234840e5577bf10d9e6bd4d8000e63dd1c39c7cc6e1af231a86d8bc6153a114310f4bafdb2ce5c7c0fb1db5bef8cb527081d88ad190fc7da86db3ee36ef60ac9388b7d92ea6ba4b94714f1eb24c155592ad76165f01484aec0d17c5a3fa8a2caf783f384211d2da437c820c841e7fc05ed19a24aa381addc42e52fab20dfaf16791d9215854a14073efa785b4f6c5add240515d9000a892123bfd6530150205cffb0fd82b705be6816c4fa02cb52795e8280c59325f32158e882335c2415d67aac700473777f44f863a08c9947b9805840abebcf3417d85cc65cd8f8f749f5c4ae98039018fba0e09106fcee04bfb22d563764f15a3e7e11a111df566579b87cbf10172447d7b83da5dfae767a89a78f9f4a848db4a4a24af8bd9f15d1ed0f404636dc3b0aa76c46cdf56f1fe821e2ca6e74503fc99303185276b76119ed04b522a22d411f90828389883c7205936a1509a130f139cb76edf30ceb86af9f718cb7fdf8fd5737e7d8b4729ce89be283ede52076c8640fd6f00292c0f099fe75ecadbcbacce6c2267e10d02a2d543566b27c8bb933906154abeebff089d92a54336bd69076cfd50feb773873f127eb3d35f4be4cf8a8f38705c115f9c3d6ef3d4c5b50dd03e9dd3644eaf96ce73195a135a82f4653dfdec4c76a9f3ca15f36e80bf31200bc9aff3419bbccb07df754ffe4da430010a4f8f5575bf6c8470fc4536f751641349b911144ecb7a5a745cdda1d8d43751965bd83a6663a460bb13f0def2fb3d430bd7769e5216968ea5fcde1a4a97870bf375b51056432d642a918d5081c00d1dab9e531d244a513d1f9932dc71029abc7dbdac9c32a68f4b9d49c98add7183a056e35065e6de83df16f6222f972862a98f13c5186bac786671283d6847e1d170ff2662f565032ae9278f0302a923933b9a5fc6ba6f4c1322c64d57263e658a46d30c8f07a0442d474f0f78b0d3440b4d4220fd3f2542b94ac09e5c1757fe4e64fea5db13ae4967f5651fca47d6b1642e8251c84f44ab0a63e23fdc320d678316e785854cdf9863304642943a27a236a85ef4ecf66daf01794968c67f218194ea7fc18a47969c8665416488f2a6a5b0d981823af104d819e9897f87fece809b0dd986d905c949ac0c64689809d432df57a4f4e741f39fd5aeb1e43a9c5ae40e61a268a9d3998086f79969afc8d0e2a1003d6643169096ac7edc9fb652a78a97039d0d619400a5cd12aaa30dee228026abf69bb463bc19889f63ee1c4bb822c7234ca73bb899b37456476d281dbe485df7e7fde5f3bd8f1e33ea2b9929e5eeed203169955a8d9be5109c0c61b944964e630682556721a012e4b4beb66bdebc90f0e8aa07f5e4441e46e521e4aa6dc3b30fb01a1beec695f67bcfb4f46d9c40a4cace9c683030c754f5c8fc53558e2599657b74a424fdd258cd199be53bbe6da5c82243a6a6f482f8f020644ff74d7950ad2d704f38e2fba9d2f590b9d6bdfd058a7c405c2d936cce8f74b77a42cf9e1a271f7225e7649b321480dff78ebe9da64512b14982e9b67b7e4f044d7c60544a8eec0756d6fc7ed78e415f249483ffa0fc806c35ef41ac5caf391c55a03f1659a27bb1db6d57e12d2d4feaee34f486508022a5e96e9822118a381e248829ceb2cc1e29aaa1d572297f26d226a6f1c186d03c7d7f3b1fcf73afc615eb07f3e4bdbc1c60babaf61e37b13697a7f613428f4554ba0a39b4bb563ef7b367ec87e35adf2c3601e8ede6b9e665c8c17edbaf0cf42f91ff0bea3a0fff3929a0d3e46df2ea1e4422498a8bf9bb6107e5d1de686ecb3c79f76ea9f730eec0eceae1ce8aa58acc1ab295151d09722dddf5b7a300a32d8faa94146209506751b6abadcd9a8b6acb1c5605c99be7b9146599c91f4a7bca99665951415db2b187ab49296cad94434a36e10b05fcc3cbfd6ccb2bc581a1b95703769d88a53f72a126e3aa82c2f8414d8f8172519077d7dde5113bcf79a24e16250ddac5de84ae3620776bfdcf67366ace8372b642bbcf0dc87a982ab530536defd04fdf1908ae54fb30edfc6b5b69ca3dc7a1736085e916912a9ef7807f11a100b99e0078b8d96cc6ac2948a5c567d34d8b427eb51d4c9f0343c4593ee59d45152b63d27bfbfb683f2d1ae3211c43d826a68d741aaf833b53dd6eaf8b61f272a59401b6261756b78d0a1f4db5b47f3a57551f36593b60cbc84ef0692d78a7c09937aba2a57bf08b7896fa565fb20ede1665233af39823d20a761f5f78b6f11fe33ef0e45bb2c36099cc1e407b5dee9d80804992a8a6d88b134d4002899009c6d45fb8656b38bf4572a27637913462938938ab2f319e3cf4df33f826104ce2b5d69a54d51871225cafd3d8c18ddc5cdafa5564d5a9cfce18cdac36b2a0086fae818e9aa00e4a11172bdb3ce469f93d301e9d5eead2f201962148768cfeed31e17238f0aa2b73360111c9663736348bdf49c1831f0869409603fb4e17aade1765ffcade44d849c4fb07cf6b2129895d15df5499c7f5c31d2a4244daf1d5e34dd9a259db8009057201aa093ad96980f97038877cf4090615d498534e6b1c65fbc1fd305e782201d72869b1de627f47d5142f466ce5b59d2eefeecf2ca3fd44d876e9d5bddf7a25aafd07c32a41ce467463ba07251a7e221b6a6131218fc7253bc3b46b159ebee1c587e25541e5a7297e5010a963104e5bf85879f41d685d8c96ac52627caf540f964016434321ce7c28c1af54b597cdb6637a8821d85b325230f061ab008277f0cee8c6eaddf8e3c30911472d506469385e9785d76d6559731941f26d416eb321fb5ed33a98f0639d52e49ba18e1dad3f54fb957bafe948041e12fc7d3c74fcf546abfb048f8bd324029aa1f763c56aa8fc56808787392a65c1260d9342c831c6c3110b007720f803d3b62ce183cbf14f2742deb5f1b9fbd23f7f56b96bd6acdb6d9c3d1a8bacce02f1fbe015f7006ed21568133eebe61aa1dc4e84010512861b4bc5bc08a6dceaa91c4219646133445b71e4cf42f8e7d446b95faa5360839e877ecd3178a91901e056d0f41ff9145612d86db42dbc090724dc8d488ac24f8d9a13ffcbcda5f0725b541db726192fbc34245e671489ad2c5517a9ec00be6fbd80ef211da7d532ad32f77416d4e0d16b4241fef414ebb3df0b5f04dd81dd03b4508e6a0e7baf12f1077dcd73e02ebbe09b516ae6d5ad0a5b707eee46169e4c647beda1a4c07113722046bc756ac55d596058b1df78772ba2727149b283911902cf44986047cbea8be7be4ecee6fbe3ccbc55c82a219aefd3299889fc90f66cf36052f21c0ccdc9a2ccfd668fb316d1376b374aac44c4d8efb2653f1a2b18919dd19226f7535c1770559784b83b0143e0ece5c32eb154787a044b3379ff5ed5b1dd780c83824ee792762c86e7c53e5d372d7e76ddcaf14c8fc810211258e9161d73e78b848a8ebaed0062be33581cda7d27513f4c468123d67353e021f905476f927486ffd9d1f1965d506b8a45b4f8945c74a3dba42351f248321bb0d4f6adaa36eed7fb53be1a32362132977d035d377ca952a17bc3ee9928682be710b813ae2916af478a1d7ca21b466048e1b02be135d01e3864fe1d600ffc0373e2777c30b036d5b603f51244c8217283e6b25049c7862a576c01b09ffb5591e1c179eef9e82f1f61e35ccb2947cef7d3f8a377c9e45565ff9ad13a87ae5a7b2d848f4865bbc2ed6c9674bed8d296c23b2be33b32c46f8eb5d4dfeae7b00ed2d295fc1f7018d04776c111a46d48c99585cdbb2469b1a19ae4589b510073d56acd57c42abaf895f59458a9bb2236d06663e6bc2d86831592ee75102c834e273bca7de0c33bed7ecca2d6cc2cda44e9a53b8e6bd3e81c69e6b72a3dbd6a3e427d2772bed5ef5a95e5ad6469565a7efb2f2c8b7af3e9b49c164ba4f7ef24d4682f23455503d369ed86f30e9f85642279503421e3bd047030e1e4bac9abc39dc3e95e39338d0f67f14ea666a875d09a5a67660ae602b8a0a4f0edd3cb126e2a189e08e534339d198876d1b69bb4acc644c9800906d0cc65e8fdd6b31810fe6319638eb7b616041f24232547b573b20a5aafd3d7a19ce32ca0e05105d4dc165e29b9f3f1cee589e030c3b7741f8ea05427c86ad71a362434f7229135cf8c2034921d518f985e75894141ecbad45157cdbbdd772a06bbcd11e0039b64a918be87f12e885e25cdf5701e11adc54f7d8fd17b96d0e8d3d25863954213edd6c39780d80e502c64aa75c8d2d4fab15c0507006897af697294497b75f8034b5e041ab69374550ebeafc39b2d25d2fa5dc96bb17f82f290a4fd98b1123484913f224df4ecbfd05eb65de86f84cae1ea1428ffdda7a8ef31e5d30703cb6de231c62688087dabcc4a9c6953a28189347f5cefaf16602946cb3b4f5310eb5e2d240810dcd16468ccf40f6ae444511c365375b72f915c3b567b82ebd392dc6e35f1a1c2cb813fdd47d5538c928435990934f6cb6338cf6d80d8b93e1f9c5fa024a560484c1ba560091587f62dbe1a2640c866f1f3f8f6c1a6b8760f02d07938ffce0c267c6fe68b51422febba6982aad10784d1ca4460a893b6639d08fa1c0323d4d12153772fbb57e6498036d3ab75446d19453f4a5bb2791296c044df50287965b116b5cc25cf0058adf7f8a9622a56c72d4d3b18012736aea5e6d23c77227e13435a34847114715c286b0a20cf37f7912fe07bb343b375756e4b1483e5ec58f2b8a7e00f9108131acf483b36f3e1f3715116eaf480a37aef6fa7b84eed059b7a2c1d59c6edf1ecc4c927dd8a4c57f90ef2a57739a60c594c65367fb9f11d74bfffc262ac9cdd88acd5dbb02e2915434cdf692b41f0d7dfa23f46516eefafbd753418c2cb86697c6594398a27acae89aaf43dc5907cf87c931ff2b071425f25e36ba1e68c3a3e50059a91e302bcc4da5df67366e804d35e560beddc4433f99612bcc276bff172c46f81e0d6501b2c8209b0885910fcc33fd465e6d29058e04d3469db325afeb2120870a5600e00d0c8068800dc8daeded5e8b9320542dfd23935e5cc04807d14b916a091c80ce761ccb107c1e7a76de0b2e26e9ea7d41adb6ca212358e01761252748cc09ed8d0741db49554769094f22b17a8c7399015756d903b55b309cc8132d64fe65d753bcecbe3ad39f3472a76c98380641051c422b1aa7236cf5f7c85eb0477c6135e4914625d379d4ae9484fbbe976ace7066c1ff68a4344dc2909ee8b00c6d4e4b27d32acc94754e358c5ffc3d983a80bdca3c510e1113fe1940dd4513cb3c3ee60987abc3ec3cf31c381a154c90b87811cb4b215250dc2bd507a3f8934ed4c46e9fa51af6ae980084c1b377a0efca11e206c5dd6b4aa6645b35a9eaf9e016c4309229eb358c842d6b53c8d224b250b4f67c7b8523150332cfa1c4643139b4d7c788aadd6c55faf9019f57f41ed9b5af4420e0459bd7810e99cc8adc38788b484b1fdef79cd53e3416403585736c6b31b4f17b7d7b57799cd3214b92dd9be1537d981906746dfea6c1f23f6836efbf18ff5b4a29110fec5b9eb12cd979dbb930df1601bc99ee8379b0acb148e86397efa60e7fe782ac229bec3efa758940baec0493f324630c383b0ecbd109df946c650d9c3558e889f3ede8e84f9ca36254619a022ea81a8a9bdf64b2d547bc92c6026b9f415cd4fac790b6ddfa89ce7ed4aaddfbefd7e01820a87e6b556678a0c173eb47c58b0bf2e49a54f821612d726317c655344defd8bf8993f7376b67e3ae8fce7be38c4f8a33dac5e1e926ddcf2834104df5bd114b6f814b8837a3194968716adeeb9361bda552a0ee387d3809bab192c886547280a6ca6f56ab0534fb4f7e95cba06319711ab8beba6b696ef3bb4154f0f37a201a17ae418f5950c8af1eb95b270206bfe01ccdc4c6e78c82738ccbda26f35c0df3ea130d04c35f4f383bf041d99a033abfe58cfc7f0d34414d31c5535893db992a1537afcb88aaeb91f1c0a754658fb8401fdd0971e91aa79f40f91d49ddc8012d954ac007824fb7a2cd2054be2fa3706a389c9e00f88787bb2a76f5370d6c261f6b8fa436647f4e588054e2a868f0de6d0e8bc84a79fe83911b6ffffc7d84b59498b5149fa77e2e198c08a93cfa00c9f8ea5d3527d9765bd20da8170265f32c51b841afea3e0f161f93dd61f2e4def50178badff4e9b1dac35091ed0a2b17601432934d11f61fcc446877995f104cd5b780d675ec29c53d38a63c93a13e204f8d6d049fd040fee512f5a33f372e0464443770396c6ec4978e440deb2998c55565260fee7bc0aca7053b97c1e995d2fe0ba4418f3c4d9c975a4248a7ce057158a7c8b81005eaec0a1dea43a3db7058957896dc4232c64f182cf020cef77cde94bf35f97fa7b9b0fc5f938a16855c7cb305d3dc9cf959d254b07da0b13585fce9b77cc4d2f348473c207ea608b4d40f259cc4978663d6f65b048318e182cf6dd81435d4bb24dc9aea4f997f077b14b1fe8545e80744deadcab856cdcd4f2e6db9b7c49111394ff801bc1e2e77beb33da623fc35ed310db9c0f906850562847ca5c5c0620221911fe2c1a46f1048da6ee745ee6fc1cbba10cdcd15f021ed89bf9a8cad30d79b98dba96f9f0be5818b0fb04f27cf9ce084edabf5ae66ae70685a0386eb052fa87f6f6d906a8673bacc52d9275f8e36f274b7feb419e929694d379b1601bfaa1c3466d665579ccd9e4db87ff203c3883674157cd2f4f06910154599b98b5ea8a68e1727034b606e72cdc29d448f1b6ba7d35fd7b35a86b137a4911d05c5356d2c0f5a9603124f091136c5044c47e5b6b41c14dd1707221fa70416d0723967f60e7ddfa11617d616e066d9c1f0f91247cd66bd2c5bf17fdf070e52195e084b6b8f110ca19f2bb46e233dc8e117e8b6035b63681e159e45f6f3e826780095e8a31fa0ca55edfff6bd670748dc6d05505b3e25762d1d48b8a26e3b746ebb194f28ae02d5cc3c3158e251654f6ecf9ff45587e8f93bd42ff3bb6d2aa32c36c8b78cf1b29b53d3896916c61a38d1e54290da2dc07f66b1e70fb4dbbf51022864e26fa3fc29706771bebfc62277f7765d1875fc50b746ed91497ba275261b39b1ac8fadc6eacc55af43773cca4c040a6fd03116a0864033f7b3aa0fae8cbf60681359778f0044f68cfaec1f75786d4c2cca78685cc7f2779401b8f52b778ba3e7f58e26f5394319e7dac8295805ed8fca8f3266b2177a4e07155638a73d3f52b39d586e70d5ecaa275b23fb1c129bda1bc27b5db1320185644282b3d341387bce0182eb44d0416da42d9a877bbd396524bc417212e1926d50d19979d2dca70f226f6f3ed08d2c3d496ee929123313cc17305cba41bf26bd31abdf987ee7ce80016726552320e7c463d4b9a06d7877cbee99cba81b6b359bcd4eab6fe0e1f8a42fcb800c9c5791219680ce9754dc2b2930ca55d20033619c76bbffe32b430443cba67dbfdd1bd41cc559dabd7839b7a08a0300c9420ba19c8359dc0c85023132620d6856ad04340d32cb59fdbc65155611021e389a966d1cb370a63dd76a39d8c5c54c6e080874eaa5b53e704d72be54f3c77ad0aad857fbb7643c9dba2ccbac45eb9191520d9696ac84793747bcd03eab0d8e9eb6acfb7b9d94bf67ad86bb46fe55f57dba6223a6309aed9c6212ddf0e65eb1fb2cba26bd53689ed6f8d9fddf7e103d2bc1a80306dd4c02d6744953aef212e97d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4148af44603883bb4c869e4972b84704"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
