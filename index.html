<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://api.whatsapp.com/send/?phone=%2B201015817243&text=Ù…Ø±Ø­Ø¨Ø§ ðŸ‘‹               Ø§Ø±ÙŠØ¯ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙƒÙˆØ±Ø³Ø§Øª Ù…Ù† ÙØ¶Ù„Ùƒ .&type=phone_number&app_absent=0"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Get Password 
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>This is a courses website.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

 <!--!   <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>!-->

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08f1f687309812c199a1eef9a7785a7c572174d5c72dd07b5f45253a5a14e2815f707bce0485bfa9248a1d29d7ca50e6bde9286428f1592dd991a7626bbf9806dfe65937955315a1c79635d82f38ee04174bdf4581bd7d601dbe450a8bd4f3ec6ccaee0dd72f8124c3d50774a6e36cf8cf251313120d8c5552f2388dd4629eaedf1f9eb92663b11ea94fea75680d6bb30ef968aa89e90524883dec51b74dc2c84eaaafe8a49dcd01857cb0230d4eb4e0f8fe354e6be2582931c88f9b96592d1163bf68af6aaa2f98440a666c53d585035940fab01090c03306d81006e07983b751c971cb040fed0e30781150569c466e9071d3e935dea315358e541e26ded3921c9d9b02411eecac2112283a401b184cc3384cf6b36df186bfe24253f16b0a0a027c9ab80fd48ef14213fc16624eaab6fb10c2a20ff715d3ae71fa066d7cc65f5e654fadafffeb8ffa043879788da83a95aa85b52ee04dda13dc3e2c2d7a070a66642e0ff71badf9ddac639a9dcfa37d001f048881a64ebdbdfc2901916822c939d2009e33ee198e7429625da440f0a65f4edaf18cfd0079c8b175fa7f9636de89db6cd3517861a8b0d967f5e699a3633959767215c4aaeddf45b5f8398061be3caf16524c63401a9b456068473bb5e6188ff3ebcac1a991ea190ca7287a8ecff42073b06dcbc765b5dea2d716842dc1c862ea48fa217c4deded7820272214f1a3f59500fe91a06f440d4f02cc6e3a876e8e78cf3664f83cc8c38be650db15fff71160f5312dac0d68fe5be4065ed8b8792039436852d94a9dd8e94b9e593ca84758025925f64adfb72563c686ae32709b8a2b186fd0dbd75089243c34a0f8f94a8e2c54082e300d2df51b3587af5b2d36b2f32815bb1c979e3acfda91cd77ddc053b6811cc6033321f2d72b06c63b85585718ba906ea9c8b056ddbc191353de4ccfe3d9b8fe3b5c89fe98c35a05e2007633d774f3f970332dc2e0a2a9af439f68613e374e9c74c5bc9f5cd49f677bd87ef919a269217a9892dd934b665b6324680ec902b6f8b40710e2069e991b307080901c8e31997b5a42fe9b2b0d561060c4bc00bd8d914b2e3d81d6ed690af834c4212e59cb8497499460a790ae259306520c6eb12643ce5f398029565786764487bd1e1b0a4e4e42158547ff29c497fc1a61685181196a6799c855fac49a90dc99cf2c262ba7edbda9e0c558ee5d316f153611aadc3f12ce615ab7e22b12f2ff20994b85942bbb42a2a64f2cbce5f997000c761bb3efe8c72193feb3cfb0f3374b9763ee9ead70827ddd56c39492ccfd05fa4bbeebc8e5cef304c789aacf02b9b37464f49aaf6a773d6f8519290e023691336159254f07922a1afce3ad2d59a41f5118619f432ee26e5e4b716a61480a3aa2de8d9429808fe35bd56bb1fed32ade05555ec5a6a1058135bdd641c2bd83eca220afdb6dbbdf01114691c9b878ba665305f8b7633c796a441e366356ad247d9944bbe43d756a41780e4dc058d22a357ab0ac2e333887134c70744af897b9dc3c01aeb4852c678dcebb800f8bc7d29ba4587e050afe2080f7423ecb867242ea0136feb923a6d09ec1b184e1aa030229ee88656f796906eb93c13ca32e1a83ba4f4cf614a3b487a66a781312765fe17e6d9b9f7aebeeb7c6c343abe33ad143afb29e9040d7af42feceb81639d64d249e0eaee5545e10cb80e25218bab53465d2cc83299728318fc47f4f2ddd0bb23ee16faea645f850fc9b902e1a7df6815c8439d61c9c30fc15153769def469f06de1b72ecdeef5fffab53ca308cbdf6d3915df6a423cce96b92fb9f1d2d4410d6aa973c5725ba5e2b00b457d831bd12bd85d8280c6de5acd93140c9ff0227e202996d10063183698986b6b10d70396b35532a673ce53af94f3b719e6630ff10b798be4d0a7df9b5ee29d31bb0f26153ce29316c011b7bd64b1be79c89742477bcab15e18af733fbf9a63c1148630c41f7be30913f17ad3685c31f9a37d28d2c467626fe635e7a330588b0c14b178c81ba9f1a2a5b1f3d09e07358030b3c48c1ad0dcbcf2110eb1edcce8f19132009fc3551d95cff290df62ca5e7bdc10ef38c70f3ab9f1ad2fc6497bbcc834a37c79c80f6a70a8b51de7986b0a527c73ed231ee21a57a21272d0f9bf9f834f8254f9fcee615c194452b1d4669e63f64714ea57ecf282046a991be26723dbb96809692f4f2fe75ae6ac0cf649d723d71780475ae415b271278872e7e21ac57b520d0c104cf2845f6c21cd3211890cff030f05b4c7430e4df8af3bb3a3adff5657fca1846ab1e3aac99643d90d3fb0dfde69035affbc2fa0177e14634766a5e6d093cbc0a440d09e2dcddb33a55e718dc9ef5d58baae11b2d02746a91e886dc9001589bb4ea3f35036939707908b4b2c5222f14032f930c970a9a85143d31a18fffa04232242e4f4bf1e263dfa5b45d81dd60e0a2c3b39040074d8847e906d0a379fc3ed867aa2d70b54f7d21cf09b3257981d9911447a5cbbf680eaaf094cc590eba63a0f11578c75200ea8d5e38b9cf820190d2814a2b2ebab0f4e2c9dd754157d150e8c792e93b41d62b63b81c8daf84f0a6765c7256d802abe097311c30376ba1ef164092ebd100c1c55db4240653d56e25bb06bb94f57cf7936a271b2fd6ec9b4360b2014270f8af53ccbcd04066c42e086ea3735d1b340331be2f96b5c2ac78e5f51b0b4cd6dc7b2ae32305e224d3817dd7df1c6cc96dce7f7ac999a0b93e8beab6ac31975405f1379b063c747eab46a84cfa16f914cc8044196db717da8c80ea00b645345521c8fd1ef49ea7cb5e552a218948d988654d770f032433049072740d8103b51142ad85505a95dffc5acf86b325c6a316f9696189a1aa5d261b05af0df1a38533f7cbd00186fb48af86de7532e31599b56f056eddc57cebb0ee99dd5bef184e86f1dab621f7aacce42b55067011d839ee4bcaeebb9ddb17556e03142cf1e8bd1d838fa6a74bce9f298f9b920ba07554123ddfd330d88e4016885dcf5b7e99932006b127e14d6ec25ba2947451a5f48acb366a402a4fcf978a5abee262812858917652dc2e51ef224bba8217c32b95e841323576b8f4f9cb84173c8050203a6733ff72ce1a1a1ee0359303860911c385ee4ea3e1624ad719a6e47a19ed98f963cc1a7f2107facacc1cfcb20ca50b052ec58c2349d56e8c2930d14d79217652f60dad03d7ff38b07f3186d6fb9617678a2526b9b554cedfd4d35ab3466938e92f1d8b9c9a7c5950c608ff0e6315c8373f98d7309abcecbdd9406ef79c435dd75e075965d1bf1ae5b5eea0ba250ba067160924878cf44ccbd15463caab75b11d39b848349f4645cca57c761df4f30d6e233332d8e4f11003fd8c56927e0006a68c8063095665c647c3d6002c076fcc3e1ff34e652b3ef61bd64f0342052321d97d29229adf4f0296d6e16382f10d98fe4706ec41931b3ef8da56eb832226d059f49b7f040b58a2f55dbe34cb9d7fb9ce1c3b57f0e05583c27a05e82b63e464318d3e748cc4cf9be41dd26b526b1f581679e159509769466cdba705a7427fd7a0a14c78f349bee600d8991e072c33e095eeaf417f4d49b2bee23ddb27365f35aed938f45979947ef2451a9f71096fda5529cbefedc2c49761e929357ee803f4ed825a1040823469fae8152b734aae26c54cceff1ad234cb83b2f8cd7bb7b72e70e1ba72c85cb450b02779764ef66ee6ec242b7ee185725eecd91ba74a77d5bae9cfd8e38b24031b089ae8ec257c63535b0d6b55c44e9993b3b9a34ebf09b7320918f36c5f6d1195cfd0298caa4fcedb15004a08d1940d417ba0b46f6e64cb7efef03e5a483ea8af3fe07cde591a225bcbe9b11c09859956de6e9c9c564e93fc7c390ad6e74d28ca2f6bf17bf396bfb7ed2aeb771fc36d61019657bd5d2d1721d09008a597be90b01ebcf940ea9a9b317a8e7c3c5804abbdc10c1edf84208abc853e4ef5c142b452ea16c384791316cd6f49062928d0cd51d9a4994aabfd117c5a306710b312ef362b90fcae5221213df44f28db789c80e07b8ee3a991e5d296d52f266b19b127108ab2cbe28ec6b253fc8f47931a94a2e54877a649e41f49952bb48d616ce78a7d7feed0392797f402b2a1079064b0ad31724fb94de07dd3765fc3d6087d71ca89d4fb1eadfee24e831e9b5b1273618ee34e1bd32b098f87ec98ef8dd416e29bf6979e22cd86f98cc320090a60c3569c37d9307bf705a7b36d4603cab945c52775393b3678fdb64c9467461213aef542160531663243d7c51d200bf12530ec06e8bcf6815cde263b754074e0246d6a4faa0d5b121ed7657013bf86c9c06f528bbe36110274f51acc788274f75f190b02b5b91b847c13c7ed32b05fe04cf4edfeec1ca3536a76f52d416bcac310ff10971203c7aa63eaaae73e42f800572ee26751657149ba387deac9df89953595e19f014aa08237aed6ff22967b0ccadb27dfa08bde3cda40463906303e4255bfc12a0423a93941f82320a378703439ae67e7f4bfc770c5a03ed641fc6e74bc885f83166deac6342939642ecb93f1a26dac66ccc28a90bb1ac8cbac73e5d11cbd1432fab7f1680da9dd166b5b776baa34c1ba6e60d27acade7d592294eeb7d518cf26c6c791ef89185be3e2029afa1d59219f179327e515da36907a961a727190435bcf0767de27aba91d613bf3ea69a123c99d1ebd9c806c8a1848522473fe7b1c1166039e7a89e9e3baa987031da4422d9db9bb5b171f58eeb6803b11520e78483a53fc86abf477d409f56f1c1f4a011f4b6a538d184bb474c4219725f6b03a51863f9c66fc09cc923ca78202565a41298a05c96f6048f3561ab328605b83aef205229a4abf647243a190a8cb5d4f836255827dba5e63b90d23e78bd3c109b3697f79f7b633ad678c293f087a157e5d4c0ebb8aaf26761baf3ec9a9cd94a5288fc09bf9c527fd6fde05b78fdb29d0cbc964b02805b8a6a8ec88de06951b6e5dbb31fc58998964f162a40e321a776223b0b58e14ba75582ce171b04fc72b5228bee5c657e6662bdc1aa2a51584ad5cd2049c3bbf7e3e918dbf400b53679710696b9503c8866fd86980946f97ecf2e454712a5281be769dfef5abe41cc861a453ffc7a805e0824033a6bd2c5eb2e825bc2d650ac4d5f632cb67c7e1a57d00ab646f093b5c3d7cc47e48f63500f5d8d1a744d52418ff2ae0c9377d12a0d4ebbc785606dd2beb56b4df22dfdc94742992c7efbe40adb8d1f3e3fb97eb36b8e8086cf65702b2f68c766c44d0ebf14392912203fbc9dafb0c1a7809fd6df88f5b9a6bb495da9ad580f4d2452f2f94a2e5f9415a7d43c891390d42213e176c36861c3283eba1c0fee1f9937e6d527cb348059160ec512c93283ff5dc48310bafd3234929b361bee256a2b0254f42c46a4d062cd1ce905fe18ce218a71f17ed4fac966fdaed23916585a51d0ec46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4148af44603883bb4c869e4972b84704"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
