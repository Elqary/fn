<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://api.whatsapp.com/send/?phone=%2B201015817243&text=مرحبا 👋               اريد كلمة مرور موقع الكورسات من فضلك .&type=phone_number&app_absent=0"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Get Password 
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>This is a courses website.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

 <!--!   <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>!-->

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"845224deb26e0e50168b828b481777d6ea67a573b7c6cbc6ed476e1dcd98d49a7c401549a62286e4c7146905fda35b2593f6d88a90f6a05fbd94a4050b7a3270f50ceabd12942317096173ae68752655a08bd80568eaf326f7f6a124f36fa217b0fdee5bc9f946f41cc3196f6151736ac3bc2d7e1ef38dc76a2e81dc5d26dadc843894b39a25a2f4e7bbbee8bbc369bf3761340b742cf899290e796928565234d132a7c797d8adec80bb4bc245489ebbca1210c3e55605970a2cb0d451c4444f3f58fcc30afe1b7e5f932b3b45ebec0d5eb64ac0facc56f62bbb24b88301be36094520429d80b12fef1cc9abe264075d26092d461bdd9631c4010dd04078ae31d50f6b33d3b54536393912ab92d9025bbd3532acd5173a69bc8462ec4348c582223de1e819e6c8e5d8434a1d3e58538129604f64793a96ce22bec1def6084e33b39f23b1bd200fdae72e67f2d145d649e6c101a7698115c405980e64bddf8342c5f2b8f101ff62b88ac5b1abeebd245dd4b427427325919eeab6feee5950024f54fad6295e644763463468798105ee62cc3baaaa5bd8792202808f3747d7a56be721e1cc33b1f677835972e4a7788f845ce68c5e5eb8359aa01a988fb889f5228d4e993ebbcad5e7375b8889a6749411b392c9a444b85cf134e70a05aebed724f8f1c5823aad9ae022be91d88261a42156db3dbf9fef0929c2c4fb864d23da85f8307952346214fd96484d19eb72963d45fdcfe3da201180a3b3ec3eebc56f43dd0c51cb9957d1813feba717278b9803438c22470ba0f23bb634e0dc932968a2cee839e3f56f0804a658d8aaf597cb2edd4c2a67f1a9a4ef2497a3d169864279f41dccc066f586dcc9c0222ff35a07bb40de47b6f917304f2d6aa91a6bb655ee0d04fbbf472843bbb4e3dca403a9b9a1dcb2c5fe72263d121559bcded5ecc845459833ae5b5bd03040ec71e1c7ec8d4b7915de0509bd27e0d92d47b24ae0f344ce90e91818afa1c3317c1924401e2f53a553f8ca8847193eef507807fcbdbaa58fe8e71636a203502dcddd7b6952450f37bfbd9a39f99fa1281f8d1d1f3d6da32c8d5b7c0a686e3a87248fb650ba2685c80ac5aacc004af7ac87bfd078c8cb023488c58150e137186596a1d297fd888ee51e1aadb122a64db33fdc81e05c3da7e162adca389e996d26c3ddd1949d071e03f78b70e50067abe02c38cc6b725df1613493b49f00c948a51efbec6b8f65b844887d3bfe62e82d6f2214d41cfecdb10b2787fd39a5f648b9b78a8bdd09da722bc422014a25dcd07a360b214bb3ee829fec9c21e2d29fb7816a459d2177134fc7fee5f1017c9ab847d979a09d1a350c2e9333c08cc70b6f005c49379826ff457f134e2299c00a87a5e46c7d63d94c8b0171c742c2f72b60bf734251aa738bac30740cd74794a75c6cecb54bbf184a7e3e6584f4e83c4eae00e64b6dda1ab37390d41eb322a37921a4acf1123790fbe400dd7c7dfe1f60eee244808862b7ee295144d42421ff959a593c5d56e88cc530453122b50f9c56e2cb3427b8169575b02f6251e204b0104e1c3b032c5ea8a78822ce833c0997a58a28511f8f5c7e314ce5a5ed9e2ed1398fc05f9e47b6c9dd9acd9a930771aa208cf91a0ea76a0ad3ac039be7c0e0857bde1e0f1d3ee11a41deaa3deec5900b14134ec090a62bf7c018387e82436fa70c6b07514f0e6e09cf639f7440b47400bf1efac9ed03742ccd2e3b4a5aec7a3558f5b0e1a44498cdbcff62bd6a50d617150e01868772fa8b6f8d55b202b1c54c59e756055e853213b1e363863eb66024e2471cda942d229c627f3fac8bf3aa73dd86d233180eef0dd96984b971195870879fc3ef99fb88ba085e58c74838ea3b1d7da08276b920a9af0916fa723ab0d186b91b56df722304ad4668015e87b7b2c3f00ba690650b10d77acb8ccf515f4a97f26e865d5f85d1db098ff62eac664b5db6625f1609dd3c71a110384b9ceada1d24cb196a2e16605898a21466be3569f2bc3a9aef84aac5dc6a1308a7a8a8ab221f56bad15396236c80555926fb69cea12e1fc4f3d2bf2137d4d27f601af7019dd00f04676984f890ddd0989f60800c10fd44f35ac4f1a9c82c47338957aabdc78bcb2ad54881cc538e9b54a590a0eb0d77611f323033cd035624c8fc9f45aa955324c4d33b7770e6a1f1d453b0d2e47498589339b3760c41c9dcf223267104d0cabf3443b7fdf6d9b277e3cb91fdb63de8ada0ba530d2f7dde7d91037e0ab4474f15085235a81c16b9ea21aed2292b903141440bb08122e523df2c84e2c89258d68540d117a4fb41d45a4ae7b49f2e2f1476f10acd81ac5c8a036417b599c148c76214ce577eefa67f17d52580d2be3edee8b9251c4f26e3c24bce32028fe153c8b15d834938b9ccbee144b5b0735c2203abd3fbb67a7e14a4c6a2fc6537abc0c24ecb01c887767cf02b0977524c301a891331880e4a4490261409bbf7bc46f56ce3c321b8ba808ca2bf6cd4212f54f9a78f03788d97d69ef317fe6b9db0c514de92200a1f8f211e9cff32ad34197648a73f953cd3a6f5ce72f9e5ff05daad926a7b69eada26a47172f083e40da2365d0acfcd0811dce70cd0ddbefc7c603d89de5e9ad2d5e1fbf7a98c4cc8c095c8a002777025d0bd2c4c7327f44975415ab746735f8abdae5a1e33f12a35278a33bec565d6d3dddbfbb07ee5e618fdac23c4fabde7f90746708c39dafc92d288422d4ba4b53129f24fc7eeddc3add9d4fe65835bbbb9cde04974590508746d61d98a4119b8f95066ff3776648988b35fff421eaed377dbc87c6b602d2cdec83d2188828a624902cf465b9a38de5d4f76b7296e5c37104af33e144ed5cac922194b8e8bc121efcfc14a4b04dbe484acde9e3009fb417aff803af54faea8fd85593b4bfa34897ea22d0cb7f2099a9d867045eba1b477686c269dca295e7a1f42a3f64abd21fcc64f270944aece186482ccf13b074334c4a656a679bbf203986dcbdc10888e7a396fd3e8a9e840d47aa491c0c10200065e98604ca2562c105fd89263197fc225a319caf8ee72edeb41bce47940a3390b17a36c54d463fbb4946abaaf09fa236290c2f32118c2a2107edddb919092e78faf8f593acacbc9d6dc99b498095775d6b5d686ad49928ddcd847a31bcd0127b40d2b273a61ca2f385b0b5b750d1d11745f79eee134fece72ba22dff4f4d4b9cb20e0c7ee8f11f91d69b996b077a4c048834b1d622897c8569f5dc07c792179811764db28a7b2c66917490a2285eefdd480183ec78a9fc696538c2e94344d347f76337bdd4ca7e4f4bda04e812de352218f1c4528fc3d8661f9a971d7b349ea729a7df7d05f770c84e136d074080ba18103299181a38d3425785232c68d469859d3e85b0758526c898fd1e3b5d3a3ae577654ef2287822d90b7fe1a423c7e08cf153a87093ba40762cb1673ceb00621a69f8608269d09d064e95e3bf970ad6191ecb912231461deda766229bab6b501a968c3e8a41b898e424293ea87840f8f8589e26973c57bf27baaac0603c860e85a646a27c431fe76c38fcdc72b9e6366cb3f49888b0512b7601f41b3f37d71da94abee6c964028b0b41651a9fcff5fe0c6af126616fc8ff19a0cbc70a193d1cad09ae8fb13e7136571852c088e39c9c35f42a9ca819fda32439e2ccd77081fb449184066542d8698a99d1113207ca08a0ca99b7ac29bde106ea6feb7cba0c028361967b19dd008ec8976c3fb9c3cba44821cf942d2214e234e946cf477fa609e1eb7d8b734e3ca383abdba3d928392b0183055ab94ba304bc3921c7a60c38a7c9f67dd8b80687290d24aafe1ca170250bd9228becc13a4437b60dee6991abf41865f4e29c0865f704a45c33d7c8b9e7607712d6c09d0c39e43211c1fc7daede23516ecb9bdd649cf51e4f7110d581083490824a29b780d28ea1088bf4decf49c58475e6dfba9d2153d478c509cad81d255a7f9f9375cfdd5896deb6c1559748abcfc148208ca4706da597d3140c863f5728a4ff00ba67c3733d294ecbceedc1d6fb33caa2801753b21fdb049fbecc6579374bad538f85a72dc1cdd97d0534f1ab829410a4600071245097c792cf9c3e188be597c9851b753b32d55d402cab54c27eb1feda147d10a454d2b8b66a8cb66e177973c7952f76b101862cdc544b03d6fba7a0c659d9fa27a9c7f602195ef9345a12a7142cceba2cc2cc90e62d5dbc9bd86dea7cf16eefc5295f40546131ec23a3916bad21cb4eabdd272258976265800c2b035971da65f8cc631730666ac0522fe5eecbc45abd08c050e1efb6a775e85dfebb3920a19b4ec966b661877743f1491c775c18b97361800003ddeffbc99fad5d99d7bae2b8a4ac284809fc97e2f403747d0e07e42e7dfb8a47f246d03016eb4db82d4b998d335f895b72546d6bf4f64b9f035c212ff3ec0997ad5022652b32506569c1255cbc6c3f629055755236cf3cfec6ea12c0229df45b6f81e566da6f4fde94efc326e5d13192af694570684a0bf725c77cee9b8796fbf29d2ce84e5ede08e5ccf5cb8e5e23ae825b83546d593d9bb5cf7a79d1e137eaffb57f42e9128e1b1d9d4e78a029b408a90f9792086794cb6373ec609cd960410b312b9012bfdba10f509896cb1970f08faa8000fa92d1be2e85cde224d88fac79a20a5df18c080d855974d9655cb19593915f4d7c771014a940c0e3d682de498b37d22fbe65b974223cb6fc5761e7d85102a0a23b745e0feaeef9d576ce7b98a658905b3101bd5eefdc6570ad8473249298e32102cea77e8b27ee7110090b7daab560e66272c7806fee4d295a19277853cbf9f557fceb3f616b9b4ef58ceafd68da0b1037d8e0e535c915022bd7604681cea0ddb830498f5473789a78e8f59496b7647de1b2c538924952c024fa590dcd1bc10be9834c02da38b56eb1afdf43f666c4f11eff642359ce276b5da6baae69cb2dbe143260b4efdb71fefedf154b64ff29696a453419a631f496f48a09dedaa7a0d0cc481539a661bb5cd571c64beae0c3c5b9071c037197a8f57d112c10cfe8f243b25b2c454ab5a77374de28a2fca6ac84d2cc5bc6c78b4ffce59df79ba4493a6df0ca69e9ca7568177cf6460b827db030194b52c4b1bbcc416a09f810f64557e5e86f1994577772185c0eca6ecc331e08e5eb01a2ae9cdf2bc63b7cfe2ac65b1660a68d42c80c8f11720c9ea6250ef119cfe68c9fe5100f9371794b66354d9a098db5493fd109c2ddf63a2a7f7e8896e4e27aa7ed6daa78554f6a95878ef234719bcb6dcf1517a65c8113518bfb3b631e3a4ec2a1d960c5ef82c14a5c59c642b257b4bbe0551d791f7843a9edb886d06c5f200118256f140712828744ba36e4f84416bb0c60ce44d7d36cd2f2d6e6d7da73ecb9981c75da478a8c06fbceefeb2a8341502448b87aacfa280afd80de9c25abfc03cc6a0d2b540a40ef4da4f90d7f963e70e496cb6ceadc4a6c30513cc673119277b6175f3561953179f3bc3e418996c5e9b250653bbabf48fb7b255d3412a7f397335648a5fe3c95473311de29a1b2f54266bb267593a3005f262e5de56c99360bc57df966b8c22c00a629865ded5063ff1dd41b58ce03410d4b63ea47a43b5cea3ee59aad491286bcb4ce96d05670fd42bb27c521ca861b12c9f774a8195de01bea9b6598710788e60d8a09a4b31496fb91ca46b348c152934d53c2d68c3a419d9fba6423869647393b617de89c68f0c5e3d3d57afd8fc1fb40a75482b277eb0c157a9a2a8c32f841b4c778234da583755799b048cc337394f7c05473ff144a282242cb84f16715defa096c2679bac605929b79f1fbffe70f26e227bb27760e0caacc198e28198e70657ecbbfd13dabdf3863049ed9f937742136c66353aa0a422aadc676eccd669e01a6a131a37e321eedb71592541a674f1b906e2046cb788d3cf7785471095119bc68987a748c147d1ec6071b6d92b50e16b0e4d1ec48750dbf59d1a92b91f8e290e6f5522ef49002c5a792fe81d396d0f26b115e7ef437f79ac692cb334cbcf76b6e87b91ed2275d3ed06deef53624afed37ffde848140e374d2acc4d902a0634f0ee32caea974908e0b084d740a66fae371d806de40938531e11c46ca61a8c3d086481d913ab2d0c5a30bb22be4c5de30fa32b9fd01e97cd04e12f86435708412778b21100bb48a32c8f640de8a3a825d87a7bf9226760d3fa3dfa201ecbf317f350fdeee6b5d366545adac1840d850bf06905a22f66e92bbfddd110a74c98958d469f2e08f80fe48d1c307e830ce8ee5a5c0da06e6a32b0aa37cd41f191e21a1363a9eba3c0b52ab13f297dc645b21a5ed644fcbfc4c40d5435cd09fca69d797a0cf4124cdd5e3ffa738814d5b7b25d39439fa61b12edc6a13a1883b5f3855df7683b94546e86bdef4addfc0cdb4f6700f61361ed5048b80458ce107c0cb3f33ad4b9b7a17fbb452b98cabd3fe2e4526eacf08a95fdd9374f783259a1e4f0de6bd1fa132386b7516187590f4b72d79ac7d8da04322307f062ae1bdb6222ba87db5d4b1b738e219978f4db5cdb74383793ac3131dd6019805112cbcafb55acfc3bfea5a76f5204868342ed25e3daa4d1d44561c6e49cf0bd5cf0898b45670ff01bfd15015cb6ba326794163650611a72bffb013a9ab45f9d3d128b5b859cc06c1a6f07b98dab6b1beffe8196992de0d008ed1543937e6d1749cf5d3a2810362fc2e2b6318983731e119e89fafc780235fcd8a91ab4391fe80ea63441c5619541c8010ca3ed69cdca63b43612921794f5adf3972b4f0328e932befbdb69bb94095934b9ed20cc871ac487f9a601a95f72c47503498e1f5cbd03c14087eba2b2dbb424c8eb7409698045122790d3526733f80c3ef5afb663bed8bb5a9d35647b6bf3ca034a72455b3629cd56a120517651f37e1076273e97b3eacdb83280d5921fab660b0f0e1242a7a382f26bc2c95fbe8416260caec1f25affeaaca4a041e643be497db5f43067a6fc46c3116339e50c59a7e54971f8fc487214ad967d9c62d9a00d67c2613451fe4f31fbb7e56317b7afe922f35a3e38feb273fa84792bf570d5324acebddbbf70137f00df053b78934f8c50b1d04acfe883bee83a2be350b427093635fbda1fe11e757fd76b22617e2ffdb78029f90f28895ab83d4ab525f7deb85140a1344a5d4f35b3cb4ef8777c1dcd62eb0266b436e26d797f6f7745fae1f332c294a04b020f323c622bcab803fb6913403775a017920570553443b6bd84e01db3e9a92cd17d1cc151fdc4293bbdd89c9d40a0b0549b207e2deb0b78b1dc45c0449e9029a8966a251c7833152c039389772c7ba5a94ae26303b82d600d907ccf5a639139c34e17467eb8a0310618f102c8f44c6977781b21a6a400046d9ce5d20d3eeab6eb3b6a475b192aecc53ce7532fe9cf43c70c3eebc03913b9ddc6469badaefad39ac560fe06e5cc612c55f7cfc8cc10f701e9f93d2d61af7d6d2176cc07a41ca066c9ec5cc0786e6129d6e2a2520cf47475d309fa19ef2099c92f97180219fa8e2f29f17b3e19f77691025cb216d065c84e2cb42fcdf37e5a416761800b764e29dd23d42900551b004ffb7b5c46c28efb8a643aa8df4538ea4edeaec6835fe94aec085274c6adf7534e947844ef2ecef4efebbf74c42eddaba38a8a60597f5f7d21ea5f3118f9e56c67a4be17672466cf919e7b6b1d792989f9203f57773a45df9df86bf4c2af20a445eb7524bef64e25c5a52ace7a83429d4725c6cd5b7efcd7336271b0c9d6a7b3ae8ed7157f8bf1495850b70cfee2b91902fa28d6d2c976997ce06481d63c884ee53462d0e9756bed752043c39d377d952eeca63f5fb4e344b187f4668bd22a7dd130ee42f668ce57fe31da9ae71cafc1515e33ffe4af3cb45705c1a64694dcde974992d82e5edaf14e70cbbc82e926689373b3b2f986fbed54ac7b924630437981de9149247d8ba6fadf3d23e826d32eb7f3b972cd3ac229a0a52bd00b9d018976d11f96e2e97baafb63a03dc313a8d7dcc911080e1bbdbf1ccf96dd25ea9e836353aa015c53683b57672e2f5d8aff61ca7f7f2f6e2c58645d2e59fe36b950dc88b647c858e9a95da27051360274ebd265c42292c6040cedfe7921560b2a312dabeceedcd85d30d8810772fb03d233d2624fa5e79ed6b5e96973436feb0aea9d61d977d74b36510f67ee4200546b43d3b9f8cbe03cfdd22be7be7ad937fe9e4cdbcaa5b5291427c8a1ebe37f31c0939df33ff704997ddaa7456b8a0bbb02fc1db1e71ba3e4c540ae9b49a2fef573cc42cb0e38847c166dcb0eb4d0f960039451bb70978112c4fc39d4844f8f9a9708052850c2667db88c690eef7e717cdccae08e1c591c97d4c4eda6acd33824b0c86c2f8b428b623312e148ca0cb85fa27c10826bf78a07706bbd84a37d878f066a574a2a301c56544fd787958bf29d5e79fea5324258b5aa8a31934d0fcd37ac112bd8bee64999b493cd509a9eb354c0a3e6fe6533764b313d31cbc34d74aa4ddf7932066ecaa59153a041c04d4fb8e56d91c9cbafc61e45b576209b5bbbc637ee3f8375deb10b0f6823c022e217a1392349f235d18a935fc0c594b489b4a0caac3e0f81ad19c249a6b318600b18ae77ee83221160d6198400dcbe98fec9a405202bb39cd486b9168ad32e2317eb5091e438b48d80f7ef68047d2aad6b0696f809c87d34e0c92f0a01aeda52f3ac15aa22809acfccdc2f0f4a299e29044f83a41fbd53ae43f477fa8492ff4e068061d061a177387cbc149c2ae06be21970964df608f6abff9a6e902cd9b4002e3f26fddc237220e4ea7d7b4a79ccc7017b9d8111f027af13b75cacce215b138086985d1d74f4d6136f445a2aed20b7774b449b44a0d0d4993a8a123a7aad0d4199e9f9041d96359655d68ac53c98ae5372f38956e487ed985accccfc9647acb148e3dc14246df6aa5506c51632695f0ab4b1e2e1b540bc04a416a929dea691e071df1cb8a4a4c3609710a152c0f8524f2d96cd638eda434a0ad759bda97766e66544d3c9efa3426600d03d7838d4eef923371f0421abfd73752d8a0869bcf609c640c52ff7fd5e8b148717e4716f86166ed88ac3385a30a52d0fd5576bc36bea207e5f3c12b38aa9c21ae34fe9d1cbaeead532e6246903b0aa23fd247ef62d74bd0be520cd40824499d8532252c85ba821777e16ef8351e96276dd3e67ccf987262113200d0acdfe5b9740ecb263dc07877d36cbe30f2ad93889178765c7059768b45d07269e041b235fce4c53f58fdaae25773c29d955000e3e2a24ddc7b44ce037be80e988c151b4e0c53099554d69ba9b38c63b315cdf7dd42326ebd7baf21aae24775b687a214fef7f63f91ab17e029b2ddb9af3cc96cedb6ad1d96416744f300d3be583039343f9bb33190f9a1895f1deee3249d2c8ed955bc6c686a8f84a1450c3eb2845cba0bcc38b39fb9fa9d2f93e9990f6044ede2b76195097f7ea18369e6d9f0321ce96706d619f48442837926abb7d24aeef20d9184a8e34a5b4ba7cd9e245289f8ae515d9a57f27d654cbcdfe38c54450b993e2ce7d3ad766cc4978fb20e2322cebf63fa77b43b827cc5996b8a6c72a4cadedd8471ecd24ae542d53e084ed4753ce214013c27e80dfc82eb88093d429c393c0ae7e57553d34bca89c8e85d26988b55b8a6c201ddbdff28601aee21b42e6a137f866d89660cc08664208e435502cd4a5c4576ac45f32a67f83b50c599cb0eba5522adaf252fa8e09778cf3195f83546ddb837c07622d8de8e968fa2da5143eab5b9e236ea9dfadb81a1116965e7d870a5f3f504b237caa9dbaed099a3c46c93d83dfe98eea3512a7bfddb82614db2a312b142207c1366428ba87f1082fcaebe985d81667153a34bae9365641dfe23a7dc29bc0832f1a4e135bd201012a9626aea57304b979eb8f68cfed6a3c038f890c167afca4d65113da3c7854e6783ac69fd39b7b1033f696ad6ec9c3da4fc3bbc4cbda5759ca939c3a44759170529a11b65aac42b6f9a3602de53abdec4eef1ea172593baa952d0a3bb7b1b0f5878f41d9e991907eea5dd0be9122023d09a73808ae709b1cddea94060570b2c42e729bd977059b9539111c6f73428f70417c22f4ad9e34d17503187d3893340065a29786e22936b53d29378fcfd9bf52296593799ca3158660aac90c2983df0960329fbff5598baa3283be2e686d5557048224115901199a01071251e539643b5843abdd2dbbebbf8a4b489a0e2fc9b05090c0301e4bcf2587096aeb9d4df97b4980bdb2e8385d06ff1f1a85c58b450c17a68f734cc5be20dccfb2d5d8101ad19f1bf65c4c6754e0809e17ec3a66a43908fd78f0aa93e8e84eb1c54f3820d6d336d23acacc7c3fb70939313db320126f8fede2882245d2611d8d3e3d36a43a55009b9f53b9567d700ae290bbbc9690106f9cb1314698d66114a70a0b7e4e24816ea77a971371d1b87dc7648f94a05be903d5b47660e67e0e2f3e97ac48593bc25365cbda715b80be0c22b994b6d3101f66bef53359949f3832d51420909f36b6673c7694c1e4cf6e6b8aaf9a6cac6a5e89c59fa8c6eb935c3040854f96a7347b2b7a380d185ee04476dcdc031b4bafb0e29b11ae2eeb59b6a701c142fa75de348ab7bd184c7feeb72b94212daa3428d4fb531dddbab0bab9dc254e86fa1d8a27718cba68b721fd5414f7b8e0b753b6989a44f8ac90b25132c3388d270f88df35fc70d2ae34f44df590fa0c37c1825eed0a1e68d47e83503792c8dce2bb7a57a161041952c2bc501024222edb12319dba97127ac6d8cb92a2661ca223d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4148af44603883bb4c869e4972b84704"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
