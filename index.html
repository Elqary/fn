<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://api.whatsapp.com/send/?phone=%2B201015817243&text=Ù…Ø±Ø­Ø¨Ø§ ðŸ‘‹               Ø§Ø±ÙŠØ¯ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙƒÙˆØ±Ø³Ø§Øª Ù…Ù† ÙØ¶Ù„Ùƒ .&type=phone_number&app_absent=0"
      data-ribbon="Get Password"
      title="Get Password"
    >
      Get Password 
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>This is a courses website.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

 <!--!   <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>!-->

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a280e1754d5c5bcd2a7b86890cd22c56a565f9d2546c5ca2117ed96934760e690969a27faeff475f3857f2fd61018ea87e2614a77a5ea907d45835e2876b51a6f7fe3eefc50eb590687d433f2b54e751c63147fcc725aacebf9cde9a45b17d93850da12d565c754390ef60d741f6e3ad9a19fbc29cea9ab94d7efea640168b79f438399f0fa75e170b61d54500ec441b9a812a117bbeb79d41032e9785a354b609f8f541b170228d2aa7c4c5e1945a2a994a3c9dec5810b2cd7e3c390e82162afb3a400f0fa0b19d28968e288702560e7f017be991abf2e71af4e270652130f3f9ffc25398e165603adf11d4b4f0554c45274457b743c858786aa3fa77308a57d0c73c69e019d247e53c314e1f15a05f15bed387dbb744d8618dca9d232223e039897ffd3bb05e058ff9712c4810468a9997af3993b906a5a3a98a3b0d69c503d15123b79c0dfb23c80e300be871ab3acbf3cdd860e70f209e90d219d12184d8c32f85bf9884b0f086c9216a699f7e128324fc393647c5dcd237bdcb49724a891473ede443be6d180cadfd114e59ae0250d0e0d0884ac216128db9ee1a5901a58f5d22252b55ef8574f5a887ca57c4b4a83319d8276359d639a038d95aa3eca6b34ed4c8ae0f458b52d3817e2eca8437803ff1920c43f76ded304a9f9086376877d516980268ef6a2bce285157e42b3f9b5d15985e44ebc5e4c8bdd54510d7048fc50c7c295f3ad8c5acb4e14704bcfe43b9dce9525e6e15b61dbceecde549b6bddea583c6da8257f563f564de92096539d1b9012841ec6658b8f7e089bcff5445b98eb174fb92aa7025537f18b4ac5d9cfa33abcd2dc3db02a72aa41b79230ebf820239c301dff43173c485d84a892ee44033cffee8f192675c456a77dc371acdce58628a4faa4943b6c1d441431ffbb1f09e2ccb10433b685f813fdfcdb8162ab52f3c51dea88b2a45db796c1405eb5f912dd5797897545502bf4639d573608f9abe1c0765424a25abc26881ff3d72da6ec3d849dfc3317a3a36bd1e82da41055e13c11baa39c8a8496252b5200cb3a17e50883f3f2a65ea1d3706513624ea74290b6a2ff4110878b83ef563f7618fa0c0d32aae11d39fdf7b642252096775d5ac6a97ce614e4897e38d37812c057204481776a3cceeceeecc47a570f4c8b9fdd953a6b00c383ff59d899e3e4fdffd67c6200520f454b66cd7333adb0e45c483a3d546ceb0ee33dc3da85b74ae5fac64bddb6add1610743b1ea2262dc396bfdb46b8715da94863a911220e61d494f7e4f718f9c72e73e1efd5d4c009e9b9c7331bd6615f683f838bb9a548c0cd1ee67408247011b32b83204de222440f1412af2a6b327d821f87cbfb3976051ee78b40e0d9f069023746fbc159867be55e151f8523acee18ad238f6888968e73f02c91ac2c8cf8013cb0f0b35d3843f8d2fb829da908e2fc9a158a955c6d5c30e90f538f9fd9b9890a6dd2352409b9fe5c0631339a55be6945ad0ecbd2191c3499d2ddd1148bdd9b75388d06d356ee669ad6db7a94195888e49aa7006da2e8d844dca9c5185c37c6fc0653701a2f17b09ff6bb94da154408e9dca19e767b6a96e2d8dcf8609c930f25307c21fa7f57789cdad85babaad87e126b294d172a0eaf34eb37458a876a44ad2e3b65fbd9461f593739d9f95321568df8e2ca553093ee0934495e57b2a19c04ff22b246ab14857675e4249684d60feb5854546a031f6f528deb604f45634d21bfff14db064a3c1b644be8d0925b3a7de866d3cf3071ed2ad63297217751aa222051f6e006b17ae1203674028d54478030923f3d6a1f16fef01e24c9484d8b363dacac273b2e3ae21f9fdfc5acd5b30906d8f84d437aeedb42e8eabb50d2cf6e506f0230f6c68d83f44ac7906f6ccf0e2392ac3c0f639706e53810e91f6d60f59a6d1f2ae110a2b3fcb2e68ba337baf59924142778b2ed44ae7538780e665efcd753d1fc5946a126400c06bbdfc38280efeafed9d56d8ebb93930d8813ca95f023ba2b04a8aced51ee90a3c82b9950ab2188e7df9a4ea8a83ef2638bf4da1be6de23afe0f3b482f7ae3f37977615eff88cca790a544652977841b60eb3d1195227d742f7038a5c4c459d952d0cfa96d83fe31c0990bf15c396e91c3c2db41ba9cc8d1e2d89848022f141d95cd67120dc97e4b1eee689aea1f0b15f6a8b725318fdb8a0c46e3c521aeb9bec4af3aa2a2f8449108101e68067c73c827256d17f30d0a7f5dc709e51273f9e2eb2882c018668c88b612738932f9568478bfcc7478d1a8004db24816815ba279d54e9323c635f25222236fc3bb20cde6f6c76d6967d8d8edd74052b7bde22ad7728ae769b747c8b13932bae546fcbc40c3644576a2154281a25e6260d6178d90c18eb35dd70bcb9a685ce9ef8e5e6eaf7dac346286ba08db2a78896bd6f006835cff264c4d4d02d545d4b4378bbba759709e184b9862d67266cac44be77578c224c8d5a6a5af7871aba2146475a15414f1ca73745ab4f97c5797a531ee591b71474f8490d086c7e387134e3d600ed0d40fbc9e82133ab39e9833b68a074ab77d7c35d13e606158833b7a53fb6e154f3cefa619f903d665dcac83a749e1a924c04420715c513a5a30b7cfdf7833cc63d66525c64d197dfeb40ee67c5a4f1589c6669953c33ad57afa03a15b665a31376a8d36c210f673d45ad6d27cbbe66b9372eaf24a6a4bae775570f667e3aa8b04b5413dc1ec44e5f7d358aaa5f61a392d1703f24581bb2aadeeb3818db0ad3270dd388ddc27d1723481cd9d554a95d74772751e66e0377e6ab4b5822b6bd28a152d2feab9bd3ef59a38639ea66fcf702e5fa0bafb35692a8d993025159cb5864e380e4f8f5fbc21a09dc3ee3b491b8b0ae3b587e168dc878987d6660fb5c1f4ef727dc8fb1dbd200fc75fade96001067ef3eab4beed12dee83a2ef36c0d4da42257fb830e8541a4ecd0bf88ab7318287a442dabd36d7925010058d253600aec691d9fcc23af4c9ed98475436d1221c0393af1b32dfe247296a6451bdf934b7797bd3a9b967b7c4bdfcfeb836def78db766b9a7d8e9483ca397f8d35dc6c3005fd39bd6dc9f3d4fb0b3e7fa5bbac69cddb65b09fa6e2e3c456926760002c88acfbdd3fe7891fbaf0bfbd105dc86891b4f6cc89007e3752cd0b356ef377e778884b149de03e7651ed839a352da11f6a5aa6586a3e99894f55de0c3dede9fd96b6242a87661ff94571dcf9594da484213cb7f1971566af2a32a6a50150add4d7a9cf457dce819599fbe6e34dd03585532de1d9b78da3f4b0c6655490a5287575b9ec811397b45a73c18b7aee528ada2ec51d4d1ee572ac004cd4271904eceb6ca93dd1957a79b5b4ebab9fa4d7d6b6214a3a3fd1326f0e9ba9fc779488a818a041482674e7e1f3e7f9177bb7e63aed0a01cf88f90da0180aa244385c00c5088ca9cc216aae166337f43e50d55b1c214950443ad85b992a5335f8b719594ea0a7eb844fabc61cfae8da45b6e5ad5f94621562bf3091d82ee1910e7b6969b39d1c6558b975b166ab8566ce839d0dde7cadfd09e1be06553f4c7720b1a5b3b9377e4a637a4c231810a9d4b933185effd116eb283c5615f536b9a36aa9b07501cf214a959563bc80be47d3917431877341e4fb92a5d3cf1df3ae74b3cc8d7aca229418e08e840df574f0e17902c7465d4ba0cb790cc2cba3270216c3f505bb9d0d85f3a891844ede249142fdece000a761b19d1d9046a225f953c188c0e426c16b041044d6a666802bf5e00085ae62a61a24299d0dfdef94ae92c98013bb2d2672f15dbd65cde6fb17768f2de9de19ac4a81cd4bf9fa70e31d4e4bde2fd5aba0d8f30fdc4500ca5c1fba076eb2e21ef0f7fe882cf06ded903590bbf5e7a0cb63f80eda79c4924bc420bfc63e6bc86805511b0a7f6314610517c8595ec3b9cf7953bc38b3fc81af4205f5c38e59e8940b74b39fd6778db7d031f189cf90566fcadedcb7c0b6f5b705f33230c65c0069ca431a71146e29a6922357a0b3e358e647ffe25717da3cac4dc7a886cf29a972fc0b244cf1f10a2c3bd81c7b599485d11eb4b94cb729327214890d2299f5fbcd640f65156e4e4028fc0f25f5703a6bad2be9e5c4f919140094807e02e7b007212f1b2d11671b87767972c0ee718d4d936d3f9ab2383b3a6e84e9694768007aae053b44301e89e0a66495a533494d1604649c4589eb77022d7dbee1be9744180cbeb1fbdf451d367ed79a4aadfa0a5ca5a875f2c67dc3ed9f2ed693dc4c4b6804cf06c0af9a24462d00f5bf7da355147cdbf18ca253e5067faad05a783e4fa00db0d770b25143ddeb0e5a71bb875c749628303990d8dddabb975cdb213e269deb2b2b592a0eb1d04cc5d6e5a11154d94c153e89e277b95983fda56aa777754131aa05d16991efdd89e1d6bc8f62582ddc9ef4bbc9342e59d7849f776ef36eec700999b8439f24d78b034014a6898a5c756d50c2f387e2fb456805903d110c0155870a1cd844cb8576a95f63cfb3db24a9d4f79c10a57ad82a0ef358a31727a568fbad24a9663fee7faf2f87a4b1b9493171a3de4ef3f5730e1cea77f2ca7954a7f65eb68553aaf7159d2927c3ed2124820a8f62142d4e98fe4da91c6503baf8a387529a71388cbdafcc0715fb8cf17a0f2ef2c0c20363483bdfe3483f01e8f95f1cca58b3470cb22d7bb6a5f24c47550a7d2a134bf10d633bd3b82e75b4d1c7ece941ec14866f547a05ef0c720d885ef138daa83d7d6ea17a345c9b1997e278706a974aeaf97b851b307937873d4c9a8b28d7342aa9be080e49c263e4159d822f4237c2e638b4737ffb109b3c502aa037a8c1680ea6b7711b20edfee913b05d0902e2e98c599a4daad8cf2c7383319f3c26656d498ab0596d32efe460344f396842b6511b835aafc179861f5efcdf543a2139f0686b865c6e2f594e8dbe608964b6e55b310a7adcd7479d35e896b90338a08d10547eb92f78521d3efffa220f7c4bb71d63c1d37bd2ec0725a1388e8ebaafa2817510e15b4f0927195f19afbffa0a1a88e513038d68ace9f4065f67fa1c7d47f3d17fd840841db3901640b94e7c996a38ada71207623834316a5dd95039237a105d2181c2023d8c7e4fece6e1d35c4b53d6792151d68631e5efc75a7604ed9e28d19f028e6a12d3a769c1bdaeb6dc67ba26a15cb179ba53a8d0753909ac8e0d0b8bddca45caaa6f4954e998b243114fd8ae35c34f106351cb03a4f9717eff2655006af513a659d8b15f20e4ac77862ee9a5b4661e4c70ca3221fadec10f041db8b398bb4f8503fc03290ed43ce155848bcb9a47c2bd1d94d91cbd076e24fad148899f86989a2c793a803f239ef41c0c2387c2ec55d8d0998d9ffab7e25fdb38cd4fe4db403ead97154d57e0dc63391ced605a7119715f7338ec6c32523038bd17c1281d97cfe79cd6bc8e61e477ea5b862b5d8d1414c863a42ecdda1f50019aead975a63120ff792179114735afddd53c98a134943ec0ce7fcf4b8c1711e054b7ae986b0963569ca9cf0dc935ff4baca1ce825f5e44be78f6f150b6323b43df8b5048f271f956a096427d9ed9f7fe24387632f635291e1cf50452c1f40ef3bfe5b303be37bf7668e2aa8e13f754a3032230e1f64332db9dbed81a29a4cbc0dd44f88aa7829a8e363a5ecd02eb15403855fb7bdf506175c9370fdcb67366301521d9f31e47c1a345eb676c0a7142a7cb779fd7665ba128279115a06425a23ea844b196b23daae3c58e2c4d3a7d8eef6115aa995ec0821e66f82c38af22f5dce405f1174fe69eedfe744ce17a6259e847144c2cf8263727731ae9f603c7bec970e2866726995ba663b4a8569a627eb9f9c5ad0a88dcbedf815d51bc820dcd41616889454eec55b1d07f2ebfd72994e9fdf3f02cd16316e75b057be4e9f3c9ef85ac4287801270118dbb358aee6e402528a4ab962bb1c3822d506c1b98a7a99170f6fa15d0a9e820ebaa1bd4a3af1e9801d3e5837eeeb6de06a9cdd8bcb36c4e0017f8bd85cc09835d91960016f9ae1140ba2e9b9aa6a958fd78f86f64c64ae57e89dd1517d1c8591a0b6e14bb2de8160afd58d03ba1d6eebbba034378b9134be463ce1165e021ceb0d05f439eb5cba6bc59cc7a7f8a4f3970337ffa828b3ba112af819b64092323f2cdd99cff28c8ed6919e015efad2d1b3d983a5fd67e83d6fced6846d8bc7af081cf534448838e7811d1f335ed2b2799b73a064c0eabd4325e0c17b4a326c1ed7b98f7a5d637e12c5d99f07215e0d4c441cb27a92ef2a24796006dc532b907e613fed6436c07f58e95f61116ffe157f260a72de84e7dce3a16ef3580678e2dd88fdde24cb86aae48e82f17991f303b6a363c2f498d5406828b03237d25dee1df351559da63bd06f9b29d19b005d5919611ca5c86d0c9a1a2956f97ab2010e53fd9aab0d08b927a8471d0848befc8fc2c60d269a65753993e5503dff8e85cdf195a4f10470e36983e970964ea586cf9de0698b71b0548c9cc6b465d51e613312d11e4d2673126e011aa1570ba447b829ded428605996f36892e601b8c69608542b1f00f7d2aa7703fc322a12e666797f3a900b7c1730f13f3ff4ad643870137a4a8d63c7140c5457239ac93d5c5976defbbbfdb3adc1ea74d7d8a08f20f6916fd996fc2da9555854bbe8ba6c0bce1f6dd3f270663d135d590eaa1220f27dd1236d0d19f6ac4dabac260f90d4f7dc87ab274d1282a039d4a681f31b95d16a33952a1c3c3b92310072fdc14cfed44daae7d0267809d2f415f309d0fa764ab4c2b214e6e25526c292e5a92b58689c4b7f91dba1105b08a3bd89b8a79d81db18b2b6bbd1aa01b905b30ee9c7d2d6feda9f3894a2334391f762e4c824a5f49df2692b255d15ca178d38e9535aea220bb7a9bb0200436c251208b73d4710d34cf37e445876c0e3ebf542e6249f90645899b4916676ab107708d67485627576ae0a639357373cd6d3920331d8f2122d891f911e261315755d90b2de65ccb7465973d1f80d71caad426709b57bb5cc18b6ee7d9792232a7ce83d91b1cc79988c58ceff57b1e6f16d2600a5814bd37fe528c5b07a93cf9e9fd23fbb1c96b2a56ce21231d6195bfbe5239fc56eabf4cca321df5056bd182df9353a746e002f04f4dc027189784891db703db9b6d636ab15a829c5928b8342183be2f06fd7e0382f98f8d41ed0c17e235a027e78de9435e3999bd4064611c625282abdc4bb0ec0770c244f56deddda9a5a19ff2921ab2359b9c9ec02ec0d0b1e0f4219eab889bdb9d5860492a4ac518eda1c6aeb2a4d16b6c129b269c6a651cd4fc056d79386e276085feddecb4546feaa95275299e747843034350acc4c44a89094cb1faf10fe1b908657c15808055c12502ecef9929b9dce3058d4ba37057fd348f53943177415948f2ceecf0665c5a271958b03997e177b8edee7387134aa460d4d293a445f1fdf2d0074223f5431a5a7d139f8905c51edf2c19af0c97747c837d2865d850e56b60620bd732163addf2a3318b4f641b991312d1859fe0041ecb5eccf9692e39aea2ea053150bf775a02e6015a1627b22a1284e41fac8ed9609bcbd2ecc2356d47c3c308c5cfc38d959042d5fbb074b4c7a60e3a4386d9c3f286d3844aa317ef7482f2dced824a0a9ed0fa9164e2e1ee508f634004ac3bc29c412f1a822fcb9409bdc23076f35c176e8ebb6ec691c7b8f227261af6e8429080dc2825d41fe1f31cfc8601d785b46c1f67d837065acab79aae364f7fd4242091b8bd31693bbb09e9a220778f1a9a3f74c05febfe32cfb20b5b0df5789fa88dd6375c6416ce2031b1bbea4f5b7bb5ad0dd5247559a43a49e7bfc333e6d8147fffcab7849bd1fc84c478a7daa3c618b54ef3bffe5db8b258a38d3b117e1e73e66b3def399e4a1bd829f65aed09785c3955f8efbe92d616965fcd9babd8c91c96ef368e5debfd09824452fadbede48d205515968e908a2c529f11ac8e6b2b660c31ad876fcf037ec201b245770846325b7ccdea523b5cd53a111589c4ce2957b5e84bc15808ceae434ffb9638f458f856c5c4de656df353617e43f11bc6e89eed2f418fd31c33ea8df48e362545947df175499f3acbb0bcd7e637563eafce597d02edaea1d44b49645f7fcb9647f5abccc63a305f1daae3e6e1ce75d76b8317702a866ff1de76afc22c090031e40504b4058af6082f5a1f8c08bbbeff96a155a318e7282990ae39a1d47c3fd09d4787fbccd9877ed2d67ebef250e8bfe36dde403badcbd30226a706279c9e5a897abedc3e6ec6678b03145aaeda713f5240a82d15e0b127feb41c8ddc3a0538da45f432b5302e03e13a247d98cdfcfc48b69bf011bc8a584e5475a892aa7d0a307df0852b79f61cc3c76cd21f871ac4304a077b3bdc4d6d9a2dac891a5a9b62459b7d0c58e1c4a31ad3c1615272b82870df3a9ca0244fe48a9553b45369a2577162ffa04ffaf085a917efb422396bfb79d8c938dcd733733a4735325e074b55946222dedd907e3d6df232d06173575f8d8c81bf5d4fd5f4526b50b5b2ab8d9318cc03d6f229422868b50883dca739c7d6ddfe4e33cebaf7ea6c9c40dea640f3961807e7b606d1410c080b0b48db86eee3ec835a0eae266e1eebd5b21bedc50d8cfc571be8894558ee196a496d9414345aac5a010e92aa8bd0366b839dad832eef6b48673994614088b6a79ed85cca0a9c7ce8afc4c4a82e56527ced54024e58de28e40dfed077d3407f8045584dafaa175297903a510e22ae34553a1ca9211a83e64de3cc5ba1b766b1baa7e88be25d79dc025eb9466f3dbb82f9f189ae1b9630fbbd78a5d51fb8f535a4c5be0788c3bf7766c782b73da728c6df73eeef1124f976e8edd0022a6688d719a03c47c62b5d2eed75bdb11d015c96b175846fb484038389212734f9d3fba3bb7f56ea70f087ee18b93539ea1fee184e4cb10913e7cfa98cf4d9b63bfacab5ef03944c045665cd1eaf219f967446b90430694b3e5ed115bc8a303145dac527e6a974c47f906d9840f9379a768b4b5216a9227c80540a1fc4c3bb70852137d396c9f39670ea9077e17a0278ea3ec8b60a2682d0ba2e0feabc8d8ae176cdea10aae7814dedd0b6a6c7d4cff163f04bf95290e8b652d10fdb4832cd1fad39c302e3d9a575384f0ddb948cfaf3a9cec3ecfaddb1f3da886509c770e610f4d30b311528a3e26344d243e25cd4811d67d3cf061687a7cee9448c40399ddf4b038576f105b2dbc7d8c4f5c187f7095da356d877e0e3112f2feaeebbc55fd956b594953cad2be8125a215afe5ef957b9007ea68c1faa05fe8b8aee7afab15353754a1d2b27eccbbbc07ff5aa611a57fab68010bc8c16b536ed7523f7b6ba343a9812198679df42ef550f6de12bbf44babf8d50c85e6b9bd190531e5a5be8243813647ba353927610fd4939b0d640623bfd9f9267f2b7e0937482b71d7c689a7c05c16c4af262b3e7aaac19d9487269a86c29ffde55a4107032262b3a44e791b6893a05ab9f345dfae3d168abf0ea8b5594eb110a6d42cc18243446723e7e516af994182d734cebd6b58abee1143656b6170732252c858bf67547b9175b98419d0359e2e4cfef107cd344212a00c6aae54eb18cf325618390f24da2effc64fcdc9836d3bc51b685f840dcdf6893a3376b9b6abeb0980091d5c6d92ff69047c0b7f09736f8a147009599da27f3e618625e1feff86cb591f243a583e8dfe68d3b76deaa5263912b991652648ee93954cb0b0226b18b319d2aca63b3f20a3fddf29d3727832d06803837fe0ec807d7a19ea89630c0de721f8b9c5d94ad441a4ffeebd6464e75225a4bc54a9910504d70be87f7ede30b6699f0e73d9c8190dcfda8656a10931ca2f2d2687b6add1e2154a0b8a309f82e49aa13912a3458da3b4d5b46e23ade63015bf14f6670ce8dfdd31c02e84078fdfda9c108d85304a1f292d0063f99cae9b47250eda4f01cddfc28c08fbbe4053b46d511746d20035a898d8e4c577be286e3d65d135b8ee2673d8712e38ffac382c7ab98f6f8b93833bfecb413f503801e17ac994a392b3647f665bbbbd27f3fd238fae9d9444d77f4ce6c9ec1a19d88e6d67183193015555d1270d549517874298cb597726ffd54afc5c71d94f9b0fea81f978cd5c7d2f69b5ec63fd952df0513db4e884a24e78c625d053d58097c6d09e502b9a4b94b124404ce0aef18a1f5bf92c63dd1ebfd2cd7bd133d15ab19a745170065c505c6f3906b2f5dbe2412efadf30651162af638475a218af7ab84d366fd442d4995772419bd3116f4de57dd572b6a2e93fab97364c0efcb452b3b786e7c0f7ac34db6aa4538dc70f9f8a222a902343b2f5e9811128069966f37127228bd801b3498485f0fb875bad1d79181b276f852d9e0d71a9213d9b6d9ee590a116cec73fc181f795d2d2720306325984d63021db502a216cf9742e2dfa842a5062543fca73a10f6c37a741c301040333114371b3145fc6a4bcdb00b460f435a1711b905cbc7f169d043b2fec776a83bc7dbe9fa17d6fd5ebdfbed6386aba120249c6dd72744175c61ad576b20d0796d8760f02b5551a64c0a8e24e1d7644642c02843dfc3f6f71d20275cf817175ab4776e10767a6fed0e25422f33fe0a5cfdd9eb4f8fe7461e31e264082c9e01fa0bba943e19538cff06a9d8d61a4e264cc200fc4c94f86fe97428b753f83e28d6839c2e06e885fed5986bd58533f04ba90bb90ac6cc575e341d8b5924431cab955199bd3bdc3b2654d02a18c8b2bf0e803ff91eb4e9bf18bb193620d34d4fad97099461be297956ebebf31ea21cfada28460c73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4148af44603883bb4c869e4972b84704"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
